# MySQL一行记录是怎么存储的？
如果你知道MySQL一行记录的存储结构，那么这个问题就没有什么难度。

知道了这个之后，还能解决如下疑问：
- MySQL的null值会占用空间吗？
- MySQL怎么知道varchar(m)实际占用数据的大小？
- varchar(n)中n最大值为多少？
- 行溢出后，MySQL是怎么处理的？

这些问题看似毫不相关，其实都围绕着MySQL一行记录的存储结构这一个知识点，所以攻破了这个知识点后，这些问题就迎刃而解了。

## MySQL数据存放在那个文件？
大家都知道MySQL的数据都是保存在磁盘的，那具体是保存在那个磁盘文件呢？

MySQL存储的行为都是由存储引擎实现的，MySQL支持多种存储引擎，不同存储引擎保存的文件自然也不同。

Innodb是我们常用的存储引擎，也是MySQL默认的存储引擎。所以，本文主要以Innodb存储引擎展开讨论。

先来看看MySQL数据库的文件存放在哪个目录？
```
mysql> SHOW VARIABLES LIKE 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.00 sec)
```
我们每创建一个database(数据库)都会在/var/lib/mysql/目录里面创建一个以database为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。

比如，我这里有一张名为my_test的database，该database里有一张名为t_order的数据库表。

然后，我们进入/var/lib/mysql/my_test目录，看看里面有什么文件？
```
[root@xiaolin ~]#ls /var/lib/mysql/my_test
db.opt  
t_order.frm  
t_order.ibd
```
可以看到里面共有三个文件，这三个文件分别代表着：
- db.opt:用来存储当前数据库的默认字符集和字符校验规则。MySQL8.0没有此文件
- t_order.frm：t_order的表结构会保存在这个文件，在MySQL中建立一张表都会生成一个.frm文件。该文件是用来保存每个表的元素信息，主要包含表结构定义。MySQL8.0没有此文件
- t_order.idb：t_order的表数据会保存在这个文件，表数据既可以存在共享表空间文件(文件名：ibdata1)里，也可以存放在独占的表空间文件(文件名：表名字.ibd)。这个行为是由参数Innodb_file_per_table控制的，从MySQL5.6.6版本开始，它的默认值就是1了，因此从这个版本之后，MySQL中每一张表的数据都存放在一个独立的idb文件了。

好了，现在我们知道了一张数据库表的数据是保存在表名字.idb的文件里，这个文件也称为独占表空间文件。

### 表空间文件的结构是怎么样的？
表空间有端(segment)、区(extent)、页(page)、行(row)组成。Innodb存储引擎的逻辑存储结构大致如下图：
![表空间结构](./picture/表空间结构.webp)

下面我们从下往上一个个看。
1、行(row)
数据块表中的记录都是按行(row)进行存放的，每行记录根据不同的行格式，有不同的存储结构。

后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。

2、页(page)
记录是按照行来存储的，但是数据库的读取并不是以行为单位，否则一次读取(就是一个IO操作)只能处理一行数据，效率会非常低。

因此Innodb是按照页为单位来读写的，也就是说，当需要读取一行记录时，并不是将这行记录从磁盘中读出来，而是以页为单位将其整体读入内存。

默认每页的大小位16kb，也就是能最多保证16kb的连续空间。

页是Innodb存储引擎磁盘管理的最小单元，意味着数据块每次读写都是以16kb为单位的，一次最少从磁盘读取16kb的内容到内存中，一次最少把16kb的内存刷到磁盘中。

页的类型有很多，常见的有数据页、undo日志页、溢出页等等，数据表中的行记录使用数据页来管理的，总之知道表中的记录存储在「数据页」里面就行。

3、区(extent)
我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。

B+数中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机IO，随机IO是非常慢的。

解决这个问题也很简单，就是让链表中相邻的页的物理位置页相邻，这样就可以使用顺序IO了，那么在范围查询的时候性能就很高。

那具体怎么解决呢？

在表中数据量大的时候，位某个索引分配空间的时候就不再按照页为单位分配了，而是按照区(extent)位单位分配。每个区的大小位1M，对于16KB的页来说，连续的64个页就会被划为一个区，这样就是的链表中相邻的页的物理位置页相邻，就能使用顺序IO了。

4、段(segment)
表空间是由各个段组成的，段是由多个区组成的，段一般分为数据段、索引段和回滚段等。

- 索引段：存放B+ 树的非叶子节点的区的集合；
- 数据段：存放B+树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合；

好了，终于说完表空间的结构了。接下来，就具体讲一下 InnoDB 的行格式了。

之所以要绕一大圈才讲行记录的格式，主要是想让大家知道行记录是存储在哪个文件，以及行记录在这个表空间文件中的哪个区域，有一个从上往下切入的视角，这样理解起来不会觉得很抽象。

## Innodb行格式有哪些？
行格式(row_format)，就是一条记录的存储结构。

Innodb提供了4中行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。
- redundant是很古老的行格式了，MySQL5.0版本之前用的行格式，现在基本没人用了。
- 由于redundant不是一种紧凑的行格式，所以MySQL5.0之后引入compact行记录存储方式，compact是一种紧凑的行格式，设计初衷就是为了让一个数据页中可以存放更多的行记录，因为从MySQL5.0版本之后，行格式默认设置成compact。
- Dynamic和Compressed两个都是紧凑的行格式，他们的行格式都和compact差不多，因为都是基于compact改进一点东西。从MySQL5.7版本之后，默认使用dynamic行格式。

所以，弄懂了 Compact 行格式，之后你们在去了解其他行格式，很快也能看懂。

## Compact行格式长什么样？
先跟Compact行格式混个脸熟，他长这样：
![COMPACT行格式](./picture/COMPACT.drawio.webp)
可以看到，一条完整的记录分为了“记录的额外信息”和“记录的真实数据”两个部分。

接下来，分别详细说。

### 记录的额外信息
记录的额外信息包含3个部分：变长字段长度列表、NULL值列表、记录头信息。

1. 变长字段长度列表
varchar(n)
