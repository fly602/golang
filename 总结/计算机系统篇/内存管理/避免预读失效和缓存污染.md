#   如何避免预读失效和缓存污染问题？

先来思考下面两个问题：
1.  操作系统在读磁盘的时候会额外多读一些到内存中，但是最后这些数据也没有用到，有什么方法改善吗？
2.  批量读数据的时候，可能会把热点数据挤出去，这个又有什么方法改善吗？

咋一看，以为是操作系统的问题，其实这两个问题都是在问如何改进LRU算法。

-   预读失效，导致缓存命中率下降(对应第一个题目)
-   缓存污染，导致缓存命中率下降(对应第二个题目)

Redis的缓存淘汰算法则是通过LFU算法来避免缓存污染而导致缓存命中率下降的问题(redis没有预读机制)。
Mysql和linux操作系统是通过改进LRU算法来避免预读失效和缓存污染而导致的缓存命中率下降的问题。

##  Linux和Mysql的缓存
在应用程序读取文件的时候，Linux操作系统会对读取的文件数据进行缓存的，会缓存在文件系统中的page cache中。
![虚拟文件系统](虚拟文件系统.webp)
Page Cache属于内存空间的数据，由于内存访问比磁盘访问快的多，在下一次访问相同数据就不需要通过磁盘IO了，命中缓存就直接返回数据即可。

因此，Page Cache起到了加速访问数据的作用。

##  Mysql的缓存
Mysql的数据是存储在磁盘中，为了提升数据库的读写性能，innodb存储引擎设计了缓冲池(Buffer Pool)，Buffer Pool属于内存空间的数据。
![缓冲池.drawio](缓冲池.drawio.webp)
有了缓冲池后：
-   当读取数据时，如果数据存在与buffer pool中，客户端就会直接读取buffer pool中的数据，否则再去磁盘中读取。
-   当修改数据时，首先修改的buffer pool中数据所在的页，然后将其页设置位脏页，最后由后台线程将脏页写入到磁盘。

##  传统的LRU是如何管理内存数据的？
Linux的Page Cache和Mysql的Buffer pool是有限的，并不能无限缓存数据，对于一些频繁访问的数据，我们希望可以一直留在内存中，而一些很少访问的内存数据在某些时机可以淘汰调，从而保证内存不会因为满了而导致无法再缓存新的数据，同时还能保证常用的数据留在内存中。

要实现这个，最容易想到的就是LRU算法。

LRU算法一般使用链表作为数据结构来实现，链表头部的数据是最近使用的， 而链表末尾的数据是最久没有使用的。那么当空间不够的时候，就淘汰最久没有被使用的节点，也就是链表末尾的数据，从而腾出内存空间。

因为Linux的page cache和mysql的Buffer pool缓存的基本数据单位就是页单位，所以后续以页名称代替数据。

传统的LRU算法是这样的：
-   当访问的页在内存里，就直接把该页对应的LRU链表节点移动到链表的头部
-   当访问的页不在内存里，出了要把该页放到LRU链表的头部，还要淘汰末尾的页。

传统的 LRU 算法并没有被 Linux 和 MySQL 使用，因为传统的 LRU 算法无法避免下面这两个问题：

预读失效导致缓存命中率下降；
缓存污染导致缓存命中率下降；

##  预读失效怎么办？
### 什么是预读机制？
Linux操作系统为基于page cache的读缓存机制提供了预读机制，一个例子是：
-   应用程序只想读取磁盘上文件A的offset位0~3Kb范围内的数据，由于磁盘的基本读写单位为block(4KB),于是操作系统至少会读0-4Kb的内容，这恰好可以在一个page中装下。
-   但是操作系统出于空间局部性原理，会选择将磁盘offset[4KB,8KB),[8KB,12KB)以及[12KB,16KB)都加载到内存中，于是额外在内存中申请了3个page。

下图代表了操作系统的预读机制：
![操作系统预读机制](./操作系统预读机制.png)
上图中，应用程序利用read系统调用，读取4KB数据，实际上内核使用预读机制(ReadaHead)机制完成了16KB数据的读取，也就是通过一次磁盘顺序读将多个page数据装入Page cache。

这样下次读取4KB数据后面的数据的时候，就不用从磁盘读取了，直接在Page Cache即可命中数据。因此，预读机制带来的好处就是减少磁盘IO次数，提高系统磁盘的吞吐量。

Mysql Innodb存储引擎的Buffer Pool也有类似的预读机制，Mysql从磁盘加载页时，会提前把它相邻的页一并加载进来，目的就是为了减少磁盘IO。

### 预读失效会带来什么问题？
如果这些被提前加载进来的页，并没有被访问，相当于这个预读工作白做了，这个就是预读失效。

如果使用传统的LRU算法，就会把预读页放到LRU链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。

如果这些预读页一直不被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存的命中率。

### 如何避免预读造成的影响？
我们不能害怕预读，而将预读机制去掉，大部分情况，空间局部性原理还是生效的。

要避免预读失效带来的影响，最好就是让预读页停留在内存里的时间要尽可能的短，让真正能够被访问的页才移动到LRU链表的头部，从而保证真正被读取的热点数据留在内存中的时间尽可能长。

那到底是怎么做才能避免呢？

Linux和Mysql通过改进LRU链表来避免预读失效带来的影响，具体的改进分别如下：
-   Linux操作系统实现了两个LRU链表：活跃LRU链表(active_list)和非活跃LRU链表(inactive_list)；
-   Mysql的Innodb存储引擎是在一个LRU链表上划分出2个区域：young预期和old区域

这两个改进的方式，设计思想都是类似的，都是将数据分为了冷数据和热数据，然后进行LRU算法。不再像传统的LRU算法那样，所有数据都只用一个LRU链表管理。

>   Linux 是如何避免预读失效带来的影响？

Linux操作系统实现了两个LRU链表：活跃LRU链表(active_list)和非活跃LRU链表(inactive_list)。
-   active list活跃内存链表，这里存放的是最近被访问过(活跃)的内存页。
-   inactive list不活跃内存页链表，这里存放的是很少被访问(非活跃)的内存页。

有了这两个LRU链表后，预读页就只需要加入到inactive list区域的头部，当页真正被访问的时候，才将页插入active list的头部，如果预读的页一直没有被访问，就会从inactive list移除，这样就不会影响active list中的热点数据。

接下来，举个例子：
假设active list和inactive list的长度为5，目前内存中已经有10个页；
![active_inactive_list.drawio](active_inactive_list.drawio.webp)
现在有个编号为20的页被预读了，这个页只会被插入到inactive list的头部，而inactive list末尾的页(10号)会被淘汰。
![active_inactive_list1.drawio](active_inactive_list1.drawio.webp)
即使编号为20的预读页一直不会被访问，它页没有占用到active list的位置，而且还会比active list中的页更早被淘汰出去。

如果20号被预读后，立刻被访问了，那么就会将它插入到active list的头部，active list末尾的页(5号)，会被降级到inactive list，作为inactive list的头部，这个过程不会有数据被淘汰。
![active_inactive_list2.drawio](active_inactive_list2.drawio.webp)

>   Mysql 是如何避免预读失效带来的影响？

Mysql的Innodb 存储引擎是在一个LRU链表上划分来2个区域，young区域和old区域。
young区域在LRU链表前半部分，old区域则是在后半部分，这两个区域都有各自头和尾节点，如下：
![young+old](./young+old.webp)
young 区域与 old 区域在 LRU 链表中的占比关系并不是一比一的关系，而是 63:37（默认比例）的关系。

划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。

## 缓存污染怎么办？

### 什么是缓存污染？
虽然Linux（实现两个LRU链表）和MySQL(划分两个区域)通过改进传统的LRU数据结构，避免了预读失效的带来的影响。

但是如果还是使用“只要数据被访问一次，就将数据加入到活跃LRU链表头部(或者young区域)”这种方式的话，那么还存在缓存污染的问题。

当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到活跃LRU链表里，然后之前缓存在活跃LRU链表(young区域)里的热点数据全部被淘汰了，如果这些大量数据在很长一段时间不会被访问的话，那么整个LRU链表(或者young区域)就被污染了。

### 缓存污染会带来什么问题？
缓存污染带来的影响就是很致命的，等这些热数据又被再次访问的时候，由于缓存未命中，就产生大量的磁盘IO，系统性能就会急剧下降。

已MySQL举例子，Linux发生缓存污染的现象也是类似的。

当某一个SQL语句扫描了大量数据的时候，在Buffer pool空间比较有限的情况下，可能会将Buffer Pool里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据再次被访问的时候，由于缓存未命中，就会产生大量的磁盘IO，Mysql的性能就会急剧下降。

注意，缓存污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成污染。

比如，在一个数据量非常庞大的表，执行了这条数据：
```sql
select * from t_user where name like "%xiaolin%";
```

可能这个查询出来的结果就几条数据，但是由于这条语句会发生索引失效，所以这个查询的过程是全表扫描的，接着会发生如下的过程：
-   从磁盘读到的页加入到LRU链表的OLD区域头部；
-   当从页里读取记录时，也就是页被访问的时候，就要将该页放到young区域头部；
-   接下来拿行记录的name字段和字符串xiaoxin进行模糊匹配，如果符合条件，就加入到结果集里；
-   如此往复，直到扫描完表中所有的记录。

经过这一番泽腾，由于这条SQL语句访问的页非常多，每访问一个页，都会将其加入young区域头部，那么原本young区域的页，如果在很长一段时间不被访问的话，就污染了young区域、

### 怎么避免缓存污染造成的影响？
前面的LRU算法只要数据被访问一次，就将数据加入活跃LRU链表(或者young区域)，这种LRU算法进入活跃LRU链表的门槛太低了，正式因为门槛太低了，才导致发生缓存污染的时候，很容易就将原本在活跃LRU链表里的热点数据淘汰了。

所以只要我们提高进入活跃LRU链表的门槛，就能有效的保证活跃LRU链表里的热点数据不会被轻易替换掉。

Linux操作系统和Mysql Innodb存储引擎分别是这样提高门槛的：
-   Linux操作系统：在内存页被第二次访问的时候，才将页从inactive list升级到active list里。
-   MysqlInnodb：在内存页被访问第二次的时候，并不会马上将该页从Old区域升级到young区域，因为还要进行停留在Old区域的时间判断：
    -   如果第二次的访问时间与第一次访问的时间在1秒内(默认)，那么该页就不会被从old区域升级到young区域。
    -   如果第二次的访问时间与第一次访问的时间超过1秒，那么该页就会从old区域升级到young区域。

提高了进入活跃LRU链表的门槛后，就很好了避免缓存污染带来的影响。

在批量读取数据的时候，如果这些大量数据只会被访问一次，那么他们就不会进入到活跃LRU链表，也就不会把热点数据淘汰，只会待在非活跃LRU链表中，后续很快会被淘汰。
