#   Zookeeper
##  1、Zookeeper是什么？
-   Zookeeper是一个开源的为分布式框架提供协调服务的Apach项目。
-   Zookeeper从设计模式角度理解：<font color=red>是一个基于观察者模式的分布式管理框架</font>。它负责<font color=red>存储和管理</font>大家都关心的<font color=red>数据</font>，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将通知已经在Zookeeper注册的那些观察者做出做出相应的反应。

```
 +-------------------------------------------------------------+
 |                                                             |
 |                     Zookeeper Server                        |
 |                                                             |
 |  follower    follower     leader     follower    follower   |
 | +---------+ +---------+ +---------+ +---------+ +---------+ |
 | | Server1 | | Server2 | | Server3 | | Server4 | | Server5 | |
 | | MyId=1  | | MyId=2  | | MyId=3  | | MyId=4  | | MyId=5  | |
 | | Data    | | Data    | | Data    | | Data    | | Data    | |
 | +---+-----+ +--+------+ +----^----+ +-----+---+ +----+----+ |
 |     ^          ^             |            ^          ^      |
 +-------------------------------------------------------------+
       |          |             |            |          |
    +--+       +--+       +-----+----+       +--+       +--+
    |          |          |          |          |          |
+---+----+ +---+----+ +---+----+ +---+----+ +---+----+ +---+----+
| client | | client | | ...... | | ...... | | client | | client |
+--------+ +--------+ +--------+ +--------+ +--------+ +--------+
```

##  2、Zookeeper特点？
1.  Zookeeper：一个领导者(leader)，多个跟随者(follower)组成的集群。
2.  集群中只要有<font color=red>半数以上</font>的节点存活，Zookeeper集群就能正常服务，所以Zookeeper适合安装<font color=red>奇数</font>台服务器。(如果是偶数台，比如6台集群挂了3台，ZK就不能正常工作，相比5台集群挂了3台同样不能正常工作，部署5台和6台效果一样，浪费资源)
3.  全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server,数据都是一致的。
4.  更新请求顺序执行，来自同一个Client的更新请求按照其发送顺序依次执行。
5.  数据更新原子性，一次数据更新要么成功，要么失败。
6.  实时性，在一定时间范围内，Client能读到最新数据。

##  3、数据结构
Zookeeper数据模型的结构跟Unix的<font color=red>文件系统</font>很像，整体上可以看做是<font color=red>一颗树</font>，每个节点称作一个ZNode，每一个ZNode默认能够存储<font color=red>1MB</font>的数据，<font color=red>每个ZNode都可以通过其路径唯一标识。</font>
```
+---------------------------------------------------+
|                                                   |
|                     +-----+                       |
|                     |     | /                     |
|                     +--+--+                       |
|                        |                          |
|             +----------+----------+               |
|          +--v--+               +--v--+            |
|          |     | /znode1       |     | /znode2    |
|          +--+--+               +--+--+            |
|             |                     |               |
|      +------+-----+               |               |
|   +--v--+      +--v--+         +--v--+            |
|   |     |      |     |         |     | /znode2/lef|
|   +-----+      +-----+         +-----+            |
|/znode1/lef1  /znode1/lef2                         |
+---------------------------------------------------+
```
## 4、应用场景
    提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。

-   ### 统一命名服务
        在分布式环境下，经常需要对应用/服务统一命名，便于管理。
-   ### 统一配置管理
    1.  分布式环境下，配置文件同步非常常见。
        1.  一般要求一个集群中，所有节点的配置信息是一致的，比如kafka集群。
        2.  对配置文件修改后，希望能快速同步到各个节点上。
    2.  配置管理可交由Zookeeper实现
        1.  可将配置信息写到Zookeeper的一个ZNode节点上。
        2.  各个客户端监听这个ZNode。
        3.  一旦ZNode中的数据被修改，Zookeeper将通知各个客户端服务器中。
-   ### 统一集群管理
    1. 分布式环境中实时掌握每个节点是必要的
        1.  可以根据节点的实时状态做出调整。
    2. Zookeeper可以实现实时监控节点状态变化
       1. 可将节点信息写入Zookeeper上的一个ZNode。
       2. 监听这个ZNode可以获取他的实时状态。
-   ### 服务器节点动态上下线
-   ### 软负载均衡
        在Zookeeper中记录每台服务器的访问数，让访问最少的客户端去处理最新的客户端请求。

##  5、配置说明
-   tickTime=2000：心跳时间，单位毫秒（ms）；客户端服务器之前的心跳时间。
-   initLimit=10：Leader和Follow初始通讯时限，单位心跳次数；默认为10次心跳时间，即leader和Follower第一次建立通讯连接时，20s（10*2000ms）内仍未建立连接，则建立连接失败。
-   syncLimit=5：Leader和Follower同步通信时限，单位心跳次数；默认为5次心跳时间，即10s内未建立连接，则说明通讯异常。
-   dataDir：保存Zookeeper中的数据。
-   myid文件：在dataDir路径中，存储服务器ID
-   Server.A=B:C:D 
    -   A:服务器ID
    -   B:服务器地址
    -   C:是这个服务器Follower与集群中Leader服务器交换信息的端口
    -   D:是万一集群中Leader服务器挂了，需要有一个端口用来重新选举，选出一个新的Leader。

## 6、<font color=red>选举机制（面试重点）</font>
*   ### 集群初始化第一次启动
```
+-------------------------------------------------------------+  +--------+
|                       zookeeper server                      |  |        |
|                                                             <----client |
|   Follower    Follower     leader     Follower    Follower  |  |        |
| +---------+ +---------+ +---------+ +---------+ +---------+ |  +--------+
| |         | |         | |         | |         | |         | |
| | Server1 | | Server2 | | Server3 | | Server4 | | Server5 | |  +--------+
| | myid=1  | | myid=2  | | myid=3  | | myid=4  | | myid=5  | |  |        |
| |         | |         | |         | |         | |         | <----client |
| +---------+ +---------+ +---------+ +---------+ +---------+ |  |        |
|                                                             |  +--------+
+-------------------------------------------------------------+
SID：服务器ID，用来唯一表示一台Zookeeper中的机器，每台机器不能重复，和myid一致。
ZXID：事务ID，ZXID是一个事务ID，用来表示一次服务器状态变更。在某一时刻，集群中的每台服务器不一定完全一致，这和Zookeeper服务器中对于客户端“更新请求”的处理逻辑有关。
Epoch：每个Leader的任期代号。没有Leader时同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加。

```
1.  服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1的票数一票，不够半数以上(3票)，选举无法完成，服务器1状态保持为Looking。
2.  服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：<font color=red>此时服务器1发现服务器2的myid比自己目前投票选举的(服务器1)大</font>,更改选票为推举服务器2。此时服务器1票数0票，服务器2票数为2，没有半数以上，结果选举无法完成，服务器1和2 状态保持Looking。
3.  服务器3启动，发起一次选举。服务器1和2都投服务器3一票。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票，超过半数以上，服务器3当选为Leader。服务器1和2 状态改为follower，服务器3状态改为leader。
4.  服务器4启动，发起一次选举。此时服务器1、2、3不是Looking状态，不会改变选票信息。交换选票结果，服务器1和2为0，服务器3为3票，服务器4为1票，更改选票为服务器3，并更改状态为Follower。
5.  服务器5启动，同4一样当小弟。

*   ### 非第一次启动
1.  当Zookeeper集群中一台服务器出现一下两种情况之一时，就会开始进入Leader选举：
    -   服务器初始化启动。
    -   服务器运行期间无法和leader保持连接。
2.  而当一台机器进入Leader选举流程时，当前集群也可能出现两种状态：
    - 集群中本来就存在一个Leader。
      - 对于第一种已经存在leader的情况，机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该服务器来说，仅仅和leader建立连接，并进行状态同步即可。
    - 集群中确实不存在Leader
      - 假设Zookeeper中由5台集群组成，SID分别为1、2、3、4、5，ZXID分别为8、8、8、7、7，并且此时SID为3分服务器是Leader，某一时刻，3和5宕机，因此开始选择Leader：
      - SID为1、2、4的投票情况（Epoch，ZXID，SID）：(1,8,1)、(1,8,2)、(1,7,4)
      - 选举Leader规则：
        1. Epoch大的直接胜出(如上平局)
        2. Epoch相同，事务ID大的胜出(如上1、2胜出)
        3. 事务ID相同，SID大的胜出(如上2胜出)

##  7、客户端命令操作
1.  启动客户端：zkCli.sh -server ip:port
2.  znode节点数据信息：
    1.  查看当前znode所包含内容(ls):
    ```
    [zk: zk3:2181(CONNECTED) 0] ls /
    [zookeeper]
    ```
    2.  查看当前节点详细数据(ls -s):
    ```
    [zk: zk3:2181(CONNECTED) 1] ls -s /
    [zookeeper]
    cZxid = 0x0
    ctime = Thu Jan 01 00:00:00 UTC 1970
    mZxid = 0x0
    mtime = Thu Jan 01 00:00:00 UTC 1970
    pZxid = 0x0
    cversion = -1
    dataVersion = 0
    aclVersion = 0
    ephemeralOwner = 0x0
    dataLength = 0
    numChildren = 1
    ```
    -   cZxid：创建节点的事务ID。每次修改Zookeeper状态，都会产生一个Zookeeper的事务ID，事务ID是Zookeeper中所有修改总的次序。每次修改都有唯一的ZXID，如果ZXID1小于ZXID2，那么ZXID1在ZXID2之前发生。
    -   ctime：znode被创建的毫秒数（从1970年开始）。
    -   mZxid：znode最后更新的事务ID。
    -   mtime：znode最后修改的毫秒数（从1970年开始）。
    -   pZxid：znode最后更新的子节点zxid。
    -   cversion：znode子节点变化号，znode子节点修改次数。
    -   dataVersion：znode数据变化号。
    -   aclVersion：znode访问控制列表的变化号。
    -   ephemeralOwner：如果是临时节点，这个是znode拥有者的sessionid，如果不是临时节点则是0。
    -   dataLength：znode的数据长度。
    -   numChildren：znode子节点的个数。
3.  节点类型
   -    持久（persistent）：客户端和服务器端断开连接后，创建的节点不删除。创建节点：create path data
   -    短暂（ephemeral）：客户端和服务器端断开连接后，创建的节点自动删除。创建节点：create -e path data
   -    持久化顺序编号目录节点：客户端和服务器端断开连接后，该节点依然存在，只是Zookeeper给该节点名称进行顺序编号。创建节点：create -s path data
   -    临时顺序编号目录节点：客户端和服务器端断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。创建节点：create -s -e path data
4. 监听器原理
    1.  监听原理
        1.  首先要有一个main线程
        2.  在main线程中创建Zookeeper客户端，这时会创建两个线程，一个复杂网络连接通讯（connect），一个负责监听（listener）。
        3.  通过connect线程将监听事件发送给Zookeeper。
        4.  在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。
        5.  Zookeeper监听到有数据或者路径变化，就会将这个消息发送给listener线程。
        6.  listener线程内部调用了process()方法。
    2. 节点监听操作
         - 注册监听：get -w path
         - 注意：监听注册一次，只能监听一次，想再次监听，需要再重新注册。
    3. 子节点监听操作
          - ls -w path
5. 节点删除
   -    子节点为空：delete path
   -    子节点非空：deleteall path

6. 写数据向服务器写数据流程：
   -   不管是向leader还是Follower，都是将数据发送给leader进行写数据，同时将数据分发给Follower。此时<font color=red>只要leader收到半数以上的follower的ack，就确认写操作成功</font>，返回给客户端。
```
写流程之写数据直接发送给leader
+-------------------------------------------------------------------------+
|                                          +--------------+               |
|                                          |              |               |
|                                   +------+   Follower   <-------+       |
|                                   |      |              |       |       |
|                                   |      +--------------+       |       |
|                                   |                             |       |
|                                   |6.回复ack                     |       |
|                                   |      +--------------+       |       |
|                                   |      |              |       |       |
|                                   |      |   Follower   |       5.写数据|
|                                   |      |              |       |       |
|                                   |      +-------^------+       |       |
|                                   |3.回复ack|    |2.写数据        |       |
| +-------------+                   |      +--v-----------+       |       |
| |             |                   +------>              |       |       |
| |             |     1.写请求             |              +-------+       |
| |   client    +-------------------------->   leader     |               |
| |             <--------------------------+              |               |
| +-------------+     4.回复ack            +--------------+               |
|                                                                         |
+-------------------------------------------------------------------------+

```
```
写流程之将数据发送给leader
+--------------------------------------------------------------+
|----------------+                   +--------------+          |
||               |     1.写请求      |              | 3.写数据 |
||    client     +------------------->  Follower    <------+   |
||               |                   |              |      |   |
+--------^-------+                   +--------------+      |   |
|        |                             |4.ack |2.询问leader|   |
|        |                           +-v------v-----+      |   |
|        |    5.半数以上ack，写成功   |              +------+   |
|        +---------------------------+  leader      +------+   |
|                                    |              |      |   |
|                                    +-^------------+      |   |
|                                      |7.ack     6.写数据 |   |
|                                    +--------------+      |   |
|                                    |              |      |   |
|                                    |  Follower    <------+   |
|                                    |              |          |
|                                    +--------------+          |
+--------------------------------------------------------------+
```
7.  服务器动态上下线
8.  Zookeeper 分布式锁案例
    1. 使用zk.NewLock()加锁
9. paxos 算法
10. zab协议