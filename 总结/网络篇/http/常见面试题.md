#   HTTP 常见面试题
在面试过程中，HTTP被提问的概率还是比较高的。
将常见面试题分为6大类：
1.  HTTP基础概念
2.  Get和Post
3.  HTTP特性
4.  HTTP缓存技术
5.  HTTPS与HTTP
6.  HTTP1.1、HTTP2、HTTP3演变
![HTTP面试题6大类](HTTP面试题6大类.png)

##  1.  HTTP 基本概念
HTTP是什么？
HTTP是超文本传输协议，也就是HeyperText transfer protocol
>   能否详细解释超文本传输协议

HTTP的名字超文本传输协议，它可以拆成三个部分：
-   超文本
-   传输
-   协议
![超文本传输协议](./超文本传输协议.webp)

1.  协议

HTTP是一个计算机里的协议，它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。

2.  传输
HTTP是一个双向传输协议。HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。

3.  超文本
HTTP传输的内容是超文本。HTTP是一个在计算机世界里专门再两点之间传输文字、图片、视频、音频等超文本数据的约定和规范。
>   那HTTP是用于从互联网服务器传输超文本到本地浏览器的协议，这种说法正确吗？
> 这种说法是不正确的，因为也可以是服务器<-->服务器，所以采用两点之间更为准确。

### HTTP有那些状态码？
![HTTP状态码](6-五大类HTTP状态码.webp)
-   1xx类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
-   2xx类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
    -   200 OK是最常见的成功状态码，表示一切正常，如果是非HEAD请求，服务器返回的响应头都会有body数据。
    -   204 NO Content 也是常见的成功状态码，与200 OK基本相同，但响应头没有body
    -   206 Partial Content 是应用与HTTP分块下载或断点传续传，表示响应的body不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

-   3xx类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送了请求获取资源，也就是重定向。
    -   301 Moved Permanently 表示永久重定向，说明请求的资源已经不在了，需改用新的URL在此访问。
    -   302 Found 表示临时重定向，说明资源还在，但暂时需要另一个URL来访问。

    301和302都会再响应头里使用字段location，指明后续要跳转的URL，浏览器会自动重定向新的URL。

    -   304 Not Modified 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也成缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制

-   4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义
    -   400 bad request 表示客户端请求的报文有错误，也就是个笼统的错误。
    -   403 forbidden 表示服务器禁止访问资源，并不是客户端的请求出错。
    -   404 not found 表示请求的资源在服务器上不存在或者未找到，所以无法提供给客户端。

-   5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生错误，属于服务器端的错误
    -   500 internal server error 与400类似，是个笼统错误，服务器发生了什么错误，我们并不知道。
    -   501 not implement 表示客户端请求的功能还不支持，类似即将开业，敬请期待的意思。
    -   502 bad gateway 通常是服务器作为网关或代理时的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
    -   503 server unavailable 表示服务器当前很忙，暂时无法想用客户端，类似服务器正忙，请稍后重试的意思。

### HTTP字段有哪些？
-   host字段：客户端发来请求时，用来指定服务器的域名
```
Host: www.A.com
```
有了Host字段，就可以将请求发往同一台服务器上的不同网站。

-   Content-Length字段
服务器在返回数据时，会有Content-Length字段，表明本次回应的数据长度。

-   Connections字段
Connections字段常用于客户端要求服务器使用TCP持久连接，以便其他请求复用。
![connections字段](./9-connection字段.webp)
HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版的HTTP，需要指定Connections首部字段的值为Keep-alive。
```
Connection: keep-alive
```
一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接，但是不是标准字段。

-   Content-Type字段：用于服务器回应时，告诉客户端，本次数据内容是什么格式。
```
Content-Type: text/html; charset=utf-8
```
上面的类型表示发送的是网页，而且编码是UTF-8。
客户端发送请求的时候，可以使用Accept字段表明自己可以接受哪些数据格式。
```
Accept:*/*
```
上面的代码表示可以接受任何格式的数据。

-   Content-Encoding字段：说明数据的压缩方法，表示服务器返回的数据使用了什么压缩格式。
```
Content-Encoding: gzip
```
上面表示服务器返回的数据采用gzip方式压缩，告知客户端需要采用此方式解压。
客户端在请求数据时，用Accept-Encoding字段说明自己可以接受那些压缩方式。
```
Accept-Encoding: gzip, deflate
```

### Get和Post的区别
根据RFC规范，GET的语义是从服务器获取指定的资源，这个资源可以是网页、图片、音频、视频等，GET请求的参数一般写在URL中，URL规定只能支持ASCII，所以GET请求参数只允许ASCII字符，而且浏览器会对URL的长度有限制(HTTP协议本身对URL长度做任何规定)。

根据RFC规范，POST的语义是根据请求负荷(报文body)对指定的资源做出处理，具体的处理方式视资源类型而不同。POST请求携带数据的位置一般是写在报文的Body中，body中的数据可以是任何格式的数据。只要客户端和服务端协商好即可，而且浏览器不会对body大小做出限制。

### GET和POST方法都是安全和幂等的吗？
先说明下安全和幂等的概念：
-   在HTTP协议里，所谓的安全是指请求方法不会破坏服务器上的资源
-   所谓幂等，意思是多次执行相同的操作，结果都是相同的。

如果从RFC规范定义的语义来看
-   GET方法就是安全且幂等的，因为它只是读操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以可以对GET请求的数据做缓存，这个缓存可以做到浏览器本身上(彻底避免浏览器发请求)，也可以做到代理上，而且在浏览器中GET请求可以保存为书签。
-   POST因为是新增或提交数的操作，会修改服务器上的资源，所以不是安全的，且多次提交可能会创建多个资源，所以不是幂等的。所以浏览器一般不会缓存POST请求，也不能把POST请求作为书签。

做个简要小结：
GET的语义是获取指定资源的，GET的方法是安全、幂等、可被缓存的。
POST的语义是根据请求负荷（报文主体）对指定资源做出的处理，具体的方式视资源类型而不同。POST不安全，不幂等，不可缓存。

注意，上面是从RFC规范定义的语义来分析的。

但实际过程中，开发者不一定会按照RFC规范定义的语义来实现GET和POST方法。比如：
-   可以用GET方法实现新增或删除数据的请求，这样实现的GET就不安全和幂等。
-   可以用POST方法来实现查询数据的请求，这样POST就是安全和幂等的。

曾经有个笑话，有人写了个博客，删除博客用的是GET请求，他觉得没人访问就连鉴权都没做，然后google服务器爬虫爬了一遍，他所有的文章都没有了。。。

如果安全放入概念是指信息被泄露的话，虽然POST用body传输数据，而GET用URL传输，这样数据会在浏览器地址栏容易看到，但是并不能说明GET不如POST安全。

因为HTTP传输数据都是明文的，虽然在浏览器地址栏看不到POST提交的body数据，但是只要抓个包就能看到了。

所以，要避免传输过程中数据被窃取，就要使用HTTPS协议，这样所有的数据都会被加密传输。

>   GET请求可以带body吗？
RFC 规范并没有规定GET是不能带body的，理论上，任何请求都可以带上body，只是因为RFC规范定义的GET请求是获取资源，所以根据这个语义是不需要用到body。

另外，URL中查询参数也不是GET所独有的，POST也可以带上URL参数。

## HTTP缓存技术
### HTTP缓存有哪些实现方式？
对于一些具有重复性的HTTP请求，比如每次请求得到的数据都一样，我们可以把这对请求-响应的数据缓存到本地，那么下次就直接读取本地的数据，不必再通过网络获取服务器的响应了，这样的话HTTP1.1的性能肯定肉眼可见的提升。

所以避免发送HTTP请求的方法就是通过缓存技术，HTTP设计者早在之前就考虑到了这点，因此HTTP协议头部有不少字段是针对缓存处理的。
HTTP缓存实现有两种：**强制缓存**和**协商缓存**

### 什么是强制缓存
强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器本地缓存，决定是否使用缓存的主动性浏览器这边。

在下图中，返回的状态码是200，但是在size项中标识的是from disk cache，就是使用了强制缓存。
![强制缓存](./强制缓存.png)
强制缓存是利用下面这两个HTTP响应头部(response header)字段实现的，它们都用来表示资源在客户端上的有效期：
-   Cache-Control：是一个相对时间；
-   Expire：是一个绝对时间。

如果HTTP响应头部同时有Cache-Control和Expire字段时，Cache-Control的优先级高于Expire。

Cache-Control选项更多一些，设置更加精细，所以建议使用Cache-Control来实现强缓存，具体的实现流程如下：
-   当浏览器第一次请求访问服务器资源时，服务器在返回这个资源的同时，在Response头部加上Cache-Contrl，Cache-Control中设置了过期时间的大小；
-   浏览器再次访问服务器请求该资源时，会先通过请求资源的时间与Cache-Control中设置的过期时间大小，来计算出资源是否过期，如果没有则使用该缓存，否则重新请求服务器；
-   服务器再次收到请求后，会再次更新Response头部的Cache-Control。

### 什么是协商缓存？
当我们在浏览器使用开发者工具的时候，你可能会看到某些请求的响应码是304，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。
![协商缓存](./协商缓存.webp)
上图就是一个协商缓存的过程，所以协商缓存就是与服务器协商后，通过协商结果来判断是否使用本地缓存。

协商缓存可以基于两种头部来实现。

第一种：请求头部的If-Modified-sinse字段与响应头部中的Last-Modified字段实现，这两个字段的意思是：
-   响应头部中的Last-Modified：表示这个响应资源的最后修改时间；
-   请求头部中的If-Modified-Sinse：当资源过期了，发现响应头中具有Last-Modified申明，则再次发起请求的时候带上Last-Modified的时间，服务器收到请求后，发现有If-Modified-Sinse则与被请求的资源的最后修改时间进行对比（Last-Modified），如果最后的修改时间比较新(大)，说明资源又被修改过，则返回新的资源，HTTP200PK；如果最后的修改时间比较旧，说明资源无修改，应用HTTP304走缓存。

第二种：请求头部中的If-None-Match字段与响应头部中的Etag字段，这两个字段的意思是：
-   响应头部中Etag：唯一表示响应资源；
-   请求头部中的If-None-Match：当资源过期时，浏览器发现响应头里有Etag，则在此向服务器发起请时，会将If-None-Match字段设置为Etag的值，服务器收到请求后进行对比，如果资源没有变化返回304，如果资源变化了返回200。

第一种是基于时间实现的，第二种实现方式是基于一个唯一的标识，相对来说后者更加准确的判断内容文件是否被修改，避免由于时间篡改导致的不可靠问题。

如果在第一次请求资源的时候，服务器返回的HTTP响应头部同时有Etag和Last-Modified字段，那么客户端再下一次请求的时候，如果带上了Etag和Last-Modified字段信息 给服务端，这是Etag的优先级会更高，也就是服务端会先判断Etag是否变化了，如果Etag变化了，就不在判断Last-Modified了，如果没有变化然后再看看Last-Modified。

### 为什么Etag的优先级更高？
这是因为Etag主要解决了Last-Modified几个比较难以解决的问题：
1.  在没有修改文件内容的情况下文件的最后修改时间也可能会改变，这回导致客户端任务这个文件被改动了，从而重新请求。
2.  可能有些文件是在秒级内修改的，If-Modified-Sinse能检查到的粒度是秒级的，使用Etag就能保证这种需求下客户端在1秒内刷新多次。
3.  有些服务器不能精确获取文件最后的修改时间。

注意，协商缓存这两个字段必须要配合强制缓存中的Cache-Control字段来使用，只有在未能命中强制缓存的时候，才能发起协商缓存字段的请求。

下图是强制缓存和协商缓存的工作流程：
![强制缓存和协商缓存的工作流程](./http缓存.webp)
当使用Etag字段实现协商缓存的过程：
-   当浏览器第一次访问服务端资源时，服务器会在返回这个资源的同时，再Response头部加上Etag唯一标识，这个唯一标识的值是根据当前请求的资源生成的。
-   当浏览器在此访问服务器请求该资源时，首先会检查该缓存是否过期；
    -   如果没有过期，则直接使用本地的缓存；
    -   如果过期了，会在request头部添加If-None-Match字段，该字段的值就是Etag唯一标识；
-   服务器再次收到请求后，会根据请求中的If-None-Match字段的值与当前请求的资源生成的唯一标识进行对比：
    -   如果值相等，则返回304 Not Modified，不会返回资源；
    -   如果值不相等，则返回200 OK状态码和资源，并在Response头部加上新的Etag唯一标识；
-   如果浏览器收到304响应码，则会从本地加载缓存资源，否则更新资源。

### HTTP特性
HTTP1.1 有点有哪些？
HTTP最突出的有点就是简单、灵活和易于扩展、应用广泛和跨平台；

1.  简单
HTTP的基本报文格式就是Header+body，头部也是key-value简单文本的形式，易于理解和降低了学习使用门槛。

2.  灵活和易于扩展
HTTP协议里的各类请求方法、URI和RUL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。

3.  应用广泛和跨平台
互联网发展至今，HTTP的应用范围非常广泛，从台式机的浏览器到收集上的APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP的应用遍地开花，同时天然具有跨平台的优越性。

HTTP1.1有哪些缺点？
HTTP里有些优缺点一体的双刃剑，分别是无状态、明文传输，同时还有一大缺点不安全。
1.  无状态
无状态的好处，因为服务器不会去记忆HTTP状态，所以不需要额外的资源来记录信息，这能减轻服务器的负担，能够把更多的CPU和内存用来对外提供服务。

无状态的坏处，既然服务器没有记忆能力，它在完成有关联的操作是非常麻烦。

例如：登录->添加购物车->下单->结算->支付，这系列操作都需要用户身份才行，但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

这样每操作一次，都要验证身份信息，这样的购物还能愉快吗？

对于无状态的问题，解决方案有很多种，其中比较简单的方式用cookie技术。
Cookie通过再请求和响应报文中写入Cookie信息来控制客户端的状态。

相当于，在客户端第一次请求以后，服务端会下发一个装有客户信息的小贴纸，后续客户端请求服务器的时候，带上小贴纸，服务器就能认得了。
![Cookie技术](./14-cookie技术.webp)

2.  明文传输
明文意味着在传输过程中的信息，是可以方便阅读的。

3.  不安全